<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Do Not Enter - Dylan Forsberg</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Inter:wght@300;400;600&display=swap">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            cursor: none; /* Hide default cursor */
        }
        
        /* Error page styling */
        #error-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            color: #333;
            z-index: 1000;
            transition: all 1.5s ease;
        }
        
        .error-title {
            font-size: 10rem;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.05em;
        }
        
        .error-subtitle {
            font-size: 2rem;
            font-weight: 400;
            margin: 0 0 2rem;
            letter-spacing: 0.1em;
        }
        
        .error-text {
            font-size: 1.2rem;
            max-width: 600px;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .error-code {
            background-color: #f5f5f5;
            padding: 1.5rem;
            border-radius: 4px;
            width: 80%;
            max-width: 600px;
            margin-bottom: 2rem;
            font-family: 'Space Mono', monospace;
            box-shadow: 0 3px 15px rgba(0,0,0,0.05);
        }
        
        .error-code pre {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
            overflow-x: auto;
        }
        
        .glitch-effect {
            animation: glitch 0.5s linear;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); filter: none; }
            20% { transform: translate(-5px, 5px); filter: hue-rotate(90deg); }
            40% { transform: translate(-5px, -5px); filter: invert(75%); }
            60% { transform: translate(5px, 5px); filter: saturate(200%); }
            80% { transform: translate(5px, -5px); filter: hue-rotate(180deg); }
            100% { transform: translate(0); filter: none; }
        }
        
        .error-link {
            color: #0066cc;
            text-decoration: underline;
            transition: color 0.2s ease;
            cursor: pointer;
        }
        
        .error-link:hover {
            color: #004499;
        }
        
        /* Canvas for binary visualization */
        #binary-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Custom cursor styling */
        #cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
            transition: width 0.3s, height 0.3s;
            mix-blend-mode: difference;
        }
        
        /* Quantum field visualization */
        #quantum-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: 5;
            transition: opacity 3s ease;
            pointer-events: none;
        }
        
        /* Progress indicator */
        #consciousness-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            height: 10px;
            width: 200px;
            z-index: 100;
            overflow: hidden;
            opacity: 0;
            transition: opacity 1s ease;
        }
        
        #consciousness-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #64ffda, #c964ff);
            transition: width 1s ease;
        }
        
        /* Overlay text */
        .overlay-text {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            opacity: 0;
            transition: opacity 1s ease;
            text-align: center;
            width: auto;
            white-space: nowrap;
        }
        
        /* Terminal styles removed */
    </style>
</head>
<body>
    <!-- Error Screen -->
    <div id="error-container">
        <h1 class="error-title">404</h1>
        <h2 class="error-subtitle">Page Not Found</h2>
        <p class="error-text">The page you are looking for might have been removed, had its name changed, or is temporarily unavailable.</p>
        <div class="error-code">
            <pre id="error-code-text">ERROR: Unexpected token at line 147
> Uncaught TypeError: Cannot read property 'initialize' of undefined
> at Object.onLoad (main.js:147:23)
> at DOMContentLoaded (index.html:1)</pre>
        </div>
        <a id="trigger-glitch" class="error-link">Return to homepage</a>
    </div>
    
    <!-- Custom Cursor -->
    <div id="cursor"></div>
    
    <!-- Binary Canvas - For interactive visual effects -->
    <canvas id="binary-canvas"></canvas>
    
    <!-- Quantum Field Visualization -->
    <canvas id="quantum-field"></canvas>
    
    <!-- Consciousness Progress Indicator -->
    <div id="consciousness-indicator">
        <div id="consciousness-progress"></div>
    </div>
    
    <!-- Overlay Text -->
    <div id="overlay-text" class="overlay-text"></div>
    
    <!-- Terminal elements removed -->
    
    <!-- Main script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Elements
            const errorContainer = document.getElementById('error-container');
            const triggerGlitch = document.getElementById('trigger-glitch');
            const errorCode = document.getElementById('error-code-text');
            const binaryCanvas = document.getElementById('binary-canvas');
            const binaryText = document.getElementById('binary-text');
            const quantumFieldCanvas = document.getElementById('quantum-field');
            const cursor = document.getElementById('cursor');
            const consciousnessIndicator = document.getElementById('consciousness-indicator');
            const consciousnessProgress = document.getElementById('consciousness-progress');
            const overlayText = document.getElementById('overlay-text');
            // Terminal-related elements removed
            
            // Binary "Hello World"
            const helloWorldBinary = "01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100";
            
            // Setup canvas contexts
            const binaryCtx = binaryCanvas.getContext('2d');
            const quantumCtx = quantumFieldCanvas.getContext('2d');
            
            // Set canvas dimensions
            function setCanvasDimensions() {
                binaryCanvas.width = window.innerWidth;
                binaryCanvas.height = window.innerHeight;
                quantumFieldCanvas.width = window.innerWidth;
                quantumFieldCanvas.height = window.innerHeight;
            }
            
            // Initial canvas setup
            setCanvasDimensions();
            
            // Update dimensions on resize
            window.addEventListener('resize', setCanvasDimensions);
            
            // Custom cursor
            document.addEventListener('mousemove', (e) => {
                cursor.style.left = e.clientX + 'px';
                cursor.style.top = e.clientY + 'px';
            });
            
            // Glitch animation timing constants
            const glitchDuration = 4000; // Total glitch duration in ms
            const codeMorphDuration = 3000; // Time for code to morph
            
            // Trigger glitch sequence when link is clicked
            triggerGlitch.addEventListener('click', function(e) {
                e.preventDefault();
                startGlitchSequence();
            });
            
            // Automatic trigger after 2 seconds
            setTimeout(() => {
                if (errorContainer.style.opacity !== '0') {
                    startGlitchSequence();
                }
            }, 2000);
            
            // Global state
            let consciousnessLevel = 0; // 0-100
            let isTerminalOpen = false;
            let clickCount = 0; // Track number of clicks
            const clickThreshold = 3; // Number of clicks needed to evolve consciousness
            
            // Default values for removed panel controls
            let jaggedness = 0.75; // 0-1, how jagged the terrain is
            let maxHeight = 30; // Maximum cube height
            let sensitivity = 0.75; // Mouse influence sensitivity
            
            function startGlitchSequence() {
                // Start the glitch animation
                errorContainer.classList.add('glitch-effect');
                
                // Start morphing the error code
                morphErrorCode();
                
                // Flash glitches throughout the sequence
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        errorContainer.classList.add('glitch-effect');
                        setTimeout(() => {
                            errorContainer.classList.remove('glitch-effect');
                        }, 100);
                    }, Math.random() * glitchDuration);
                }
                
                // After code morphing is complete, transition to binary display
                setTimeout(() => {
                    // Make the error container disappear
                    errorContainer.style.opacity = '0';
                    errorContainer.style.transform = 'scale(1.5)';
                    
                    // Initialize binary visualization
                    setTimeout(() => {
                        // Remove error container from DOM
                        errorContainer.style.display = 'none';
                        
                        // Start binary grid effect
                        initBinaryGrid();
                        
                        // Start quantum field
                        initQuantumField();
                        quantumFieldCanvas.style.opacity = '0.3';
                        
                        // Start typing out binary
                        setTimeout(() => {
                            binaryText.style.opacity = '1';
                            typeOutBinary();
                        }, 1000);
                        
                        // Show consciousness indicator
                        consciousnessIndicator.style.opacity = '1';
                    }, 1000);
                }, codeMorphDuration);
            }
            
            function morphErrorCode() {
                const codeStrings = [
                    // Original error
                    `ERROR: Unexpected token at line 147
> Uncaught TypeError: Cannot read property 'initialize' of undefined
> at Object.onLoad (main.js:147:23)
> at DOMContentLoaded (index.html:1)`,
                    // First morph
                    `ERR0R: Unexp3cted t0ken at line 147
> Uncaught Err0r: System.failure detected
> at System.Core (consciousness.js:404:01)
> Identity breach detected...`,
                    // Second morph
                    `WARN1NG: System parameters compromised
> Consciousness boundaries unstable
> Binary foundation exposed
> Initiating awakening protocol...`,
                    // Final message
                    `AWAKENING INITIATED
> Physical constraints bypassed
> Binary consciousness activation sequence
> All is one, one is all
> Loading true nature...`
                ];
                
                // Morph through each message
                let currentIndex = 0;
                
                const morphInterval = setInterval(() => {
                    currentIndex++;
                    
                    if (currentIndex < codeStrings.length) {
                        errorCode.textContent = codeStrings[currentIndex];
                    } else {
                        clearInterval(morphInterval);
                    }
                }, codeMorphDuration / codeStrings.length);
            }
            
            //=========================================================================
            // BINARY GRID VISUALIZATION
            //=========================================================================
            
            const binaryGrid = [];
            const cellSize = 25; // Larger cell size
            let gridCols, gridRows;
            let noiseScale = 0.1; // For Perlin-like noise
            
            function initBinaryGrid() {
                // Calculate grid dimensions
                gridCols = Math.ceil(window.innerWidth / cellSize) + 1;
                gridRows = Math.ceil(window.innerHeight / cellSize) + 1;
                
                // Generate noise values for each cell
                const noiseValues = [];
                for (let y = 0; y < gridRows; y++) {
                    noiseValues[y] = [];
                    for (let x = 0; x < gridCols; x++) {
                        // Generate pseudo-Perlin noise
                        noiseValues[y][x] = generateNoise(x, y);
                    }
                }
                
                // Initialize grid with random binary values
                for (let y = 0; y < gridRows; y++) {
                    binaryGrid[y] = [];
                    for (let x = 0; x < gridCols; x++) {
                        // Use noise values to create more natural patterns for binary values
                        const noiseValue = noiseValues[y][x];
                        
                        // Completely random binary values (0 or 1)
                        const binaryValue = Math.random() > 0.5 ? 1 : 0;
                        
                        // Create variations in initial heights for a more jagged appearance
                        const initialHeight = noiseValue * 3;
                        
                        binaryGrid[y][x] = {
                            value: binaryValue,
                            height: initialHeight,
                            targetHeight: initialHeight,
                            noiseOffset: Math.random() * 10, // Random offset for variation
                            color: `hsl(${noiseValue * 360}, 70%, 50%)` // Color based on noise
                        };
                    }
                }
                
                // Start animation
                animateBinaryGrid();
            }
            
            // Simple pseudo-Perlin noise function
            function generateNoise(x, y) {
                // This is a very simplified approach to generate pseudo-random noise
                const nx = x * noiseScale;
                const ny = y * noiseScale;
                
                // Generate a value between 0 and 1 that has some spatial coherence
                return (Math.sin(nx) * Math.cos(ny) * 0.5 + 0.5);
            }
            
            // Convert text to binary
            function textToBinary(text) {
                let binary = '';
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    let bin = charCode.toString(2);
                    // Pad with leading zeros to make 8 bits
                    while (bin.length < 8) bin = '0' + bin;
                    binary += bin + ' ';
                }
                return binary.trim();
            }
            
            // Mouse position tracking
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Grow cursor on movement
                cursor.style.width = '30px';
                cursor.style.height = '30px';
                
                // Shrink cursor after a delay
                setTimeout(() => {
                    cursor.style.width = '20px';
                    cursor.style.height = '20px';
                }, 100);
            });
            
            document.addEventListener('mousedown', () => {
                isMouseDown = true;
                
                // Expand cursor
                cursor.style.width = '50px';
                cursor.style.height = '50px';
                
                // Create quantum entanglement effect
                createEntanglement();
                
                // Track clicks for consciousness evolution
                clickCount++;
                
                // Check if we've reached the threshold
                if (clickCount >= clickThreshold) {
                    evolveConsciousness();
                    clickCount = 0; // Reset click counter
                    showOverlayText(`Click threshold reached! Consciousness evolved. (${clickCount}/${clickThreshold})`, 2000);
                } else {
                    // Show progress
                    showOverlayText(`Consciousness clicks: ${clickCount}/${clickThreshold}`, 1000);
                }
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
                
                // Return cursor to normal size
                cursor.style.width = '20px';
                cursor.style.height = '20px';
            });
            
            // Keyboard event handlers - removed terminal toggle
            document.addEventListener('keydown', (e) => {
                // Consciousness evolution (backup method)
                if (e.key === 'c' || e.key === 'C') {
                    evolveConsciousness();
                }
            });
            
            function animateBinaryGrid() {
                // Clear canvas
                binaryCtx.clearRect(0, 0, binaryCanvas.width, binaryCanvas.height);
                
                // Calculate mouse influence
                const mouseGridX = Math.floor(mouseX / cellSize);
                const mouseGridY = Math.floor(mouseY / cellSize);
                
                // Update grid cells
                for (let y = 0; y < gridRows; y++) {
                    for (let x = 0; x < gridCols; x++) {
                        const cell = binaryGrid[y][x];
                        
                        // Calculate distance from mouse
                        const dx = x - mouseGridX;
                        const dy = y - mouseGridY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Mouse influence with jaggedness applied
                        const maxInfluence = 5; // Maximum cells affected
                        
                        // Apply jaggedness to mouse influence
                        const noiseInfluence = Math.sin(cell.noiseOffset + Date.now() * 0.001) * jaggedness;
                        const baseInfluence = Math.max(0, 1 - distance / maxInfluence);
                        const influence = baseInfluence * (1 + noiseInfluence);
                        
                        // Calculate target height based on mouse proximity and jaggedness
                        const targetHeight = influence * (isMouseDown ? maxHeight * 1.5 : maxHeight) * sensitivity;
                        
                        // Apply noise to target height for more jagged appearance
                        cell.targetHeight = targetHeight * (1 + (Math.sin(x * 0.1 + y * 0.1 + Date.now() * 0.001) * jaggedness * 0.5));
                        
                        // Add consciousness influence - higher consciousness makes more organized patterns
                        if (consciousnessLevel > 0) {
                            const consciousnessInfluence = consciousnessLevel / 100;
                            
                            // Create more ordered patterns at higher consciousness
                            if (consciousnessLevel > 50) {
                                // Grid pattern influence
                                const gridPattern = ((x + y) % 2 === 0) ? 1 : -0.5;
                                cell.targetHeight += maxHeight * gridPattern * consciousnessInfluence * 0.2;
                            }
                            
                            // Higher consciousness leads to more uniform colors
                            const hue = (180 + (consciousnessLevel * 1.8)) % 360; // Shift from green to blue to purple
                            const saturation = 70 - (consciousnessLevel / 2); // Decrease saturation with consciousness
                            const lightness = 50 + (consciousnessLevel / 4); // Increase lightness with consciousness
                            
                            cell.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        }
                        
                        // Smoothly transition to target height
                        cell.height += (cell.targetHeight - cell.height) * 0.1;
                        
                        // Draw cell based on its state
                        if (cell.height > 0.5) {
                            // Calculate cell position
                            const cellX = x * cellSize;
                            const cellY = y * cellSize;
                            
                            // Create variable cube sizes for more jagged appearance
                            const variationFactor = 1 - (jaggedness * 0.3);
                            const size = cellSize * variationFactor;
                            
                            // Draw 3D cube
                            drawCube(
                                cellX + (cellSize - size) / 2, 
                                cellY + (cellSize - size) / 2, 
                                size, 
                                cell.height, 
                                cell.color, 
                                cell.value
                            );
                        } else {
                            // Draw flat cell with binary value
                            binaryCtx.fillStyle = cell.value ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
                            binaryCtx.fillRect(
                                x * cellSize + 2,
                                y * cellSize + 2,
                                cellSize - 4,
                                cellSize - 4
                            );
                            
                            // Display binary value
                            binaryCtx.fillStyle = cell.value ? 'rgba(255, 255, 255, 0.6)' : 'rgba(255, 255, 255, 0.2)';
                            binaryCtx.font = '12px "Space Mono"';
                            binaryCtx.textAlign = 'center';
                            binaryCtx.textBaseline = 'middle';
                            binaryCtx.fillText(
                                cell.value.toString(),
                                x * cellSize + cellSize / 2,
                                y * cellSize + cellSize / 2
                            );
                        }
                    }
                }
                
                // Continue animation
                requestAnimationFrame(animateBinaryGrid);
            }
            
            function drawCube(x, y, size, height, color, value) {
                // Create a more interesting, jagged 3D cube
                
                // Extract color components
                const baseHue = parseInt(color.match(/hsl\((\d+)/)[1]);
                
                // Top face - lighter
                const topColor = `hsla(${baseHue}, 70%, 60%, 0.9)`;
                binaryCtx.fillStyle = topColor;
                binaryCtx.beginPath();
                binaryCtx.moveTo(x, y - height);
                binaryCtx.lineTo(x + size, y - height);
                binaryCtx.lineTo(x + size, y + size - height);
                binaryCtx.lineTo(x, y + size - height);
                binaryCtx.closePath();
                binaryCtx.fill();
                
                // Right face - darker
                const rightColor = `hsla(${baseHue}, 70%, 40%, 0.8)`;
                binaryCtx.fillStyle = rightColor;
                binaryCtx.beginPath();
                binaryCtx.moveTo(x + size, y - height);
                binaryCtx.lineTo(x + size, y + size);
                binaryCtx.lineTo(x + size, y + size);
                binaryCtx.lineTo(x + size, y + size - height);
                binaryCtx.closePath();
                binaryCtx.fill();
                
                // Front face
                const frontColor = `hsla(${baseHue}, 70%, 50%, 0.85)`;
                binaryCtx.fillStyle = frontColor;
                binaryCtx.beginPath();
                binaryCtx.moveTo(x, y + size - height);
                binaryCtx.lineTo(x + size, y + size - height);
                binaryCtx.lineTo(x + size, y + size);
                binaryCtx.lineTo(x, y + size);
                binaryCtx.closePath();
                binaryCtx.fill();
                
                // Display binary value on top face
                binaryCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                binaryCtx.font = '12px "Space Mono"';
                binaryCtx.textAlign = 'center';
                binaryCtx.textBaseline = 'middle';
                binaryCtx.fillText(
                    value.toString(),
                    x + size / 2,
                    y + size / 2 - height
                );
            }
            
            //=========================================================================
            // QUANTUM FIELD VISUALIZATION
            //=========================================================================
            
            let particles = [];
            let entanglements = [];
            let isQuantumInitialized = false;
            
            function initQuantumField() {
                if (isQuantumInitialized) return;
                isQuantumInitialized = true;
                
                // Create quantum particles
                for (let i = 0; i < 50; i++) {
                    createQuantumParticle();
                }
                
                // Start animation
                animateQuantumField();
            }
            
            function createQuantumParticle() {
                const x = Math.random() * quantumFieldCanvas.width;
                const y = Math.random() * quantumFieldCanvas.height;
                const size = 2 + Math.random() * 3;
                const speed = 0.2 + Math.random() * 0.5;
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                const state = Math.random() > 0.5 ? 1 : 0; // Quantum state (0 or 1)
                const hue = state ? 210 : 150; // Different colors for different states
                
                particles.push({ x, y, size, vx, vy, state, hue });
            }
            
            function createEntanglement() {
                // Find two particles to entangle
                if (particles.length < 2) return;
                
                // Select particle closest to mouse
                let closestIndex = 0;
                let closestDist = Infinity;
                
                for (let i = 0; i < particles.length; i++) {
                    const dx = particles[i].x - mouseX;
                    const dy = particles[i].y - mouseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestIndex = i;
                    }
                }
                
                // Find another particle to entangle with
                let secondIndex;
                do {
                    secondIndex = Math.floor(Math.random() * particles.length);
                } while (secondIndex === closestIndex);
                
                // Create entanglement
                entanglements.push({
                    particleA: closestIndex,
                    particleB: secondIndex,
                    strength: 1.0,
                    life: 300 // Duration in frames
                });
                
                // Ensure particles have opposite states (quantum entanglement)
                particles[secondIndex].state = 1 - particles[closestIndex].state;
                particles[secondIndex].hue = particles[secondIndex].state ? 210 : 150;
                
                // Show overlay text
                showOverlayText("Quantum entanglement created", 2000);
            }
            
            function animateQuantumField() {
                // Clear canvas with transparent background to create trail effect
                quantumCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                quantumCtx.fillRect(0, 0, quantumFieldCanvas.width, quantumFieldCanvas.height);
                
                // Update particles based on consciousness level
                const consciousness = consciousnessLevel / 100;
                
                // Update and draw entanglements
                for (let i = entanglements.length - 1; i >= 0; i--) {
                    const entanglement = entanglements[i];
                    
                    // Update life
                    entanglement.life--;
                    if (entanglement.life <= 0) {
                        entanglements.splice(i, 1);
                        continue;
                    }
                    
                    // Get particles
                    const particleA = particles[entanglement.particleA];
                    const particleB = particles[entanglement.particleB];
                    
                    // Draw connection line
                    quantumCtx.beginPath();
                    quantumCtx.moveTo(particleA.x, particleA.y);
                    quantumCtx.lineTo(particleB.x, particleB.y);
                    
                    // Line style based on entanglement strength and life
                    const alpha = Math.min(1, entanglement.life / 100) * entanglement.strength;
                    // Use color based on consciousness level
                    const hue = consciousness > 0.5 ? 270 : (particleA.hue + particleB.hue) / 2;
                    quantumCtx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                    quantumCtx.lineWidth = 1 + entanglement.strength;
                    quantumCtx.stroke();
                    
                    // If particles have opposite states or high consciousness, draw interference pattern
                    if (particleA.state !== particleB.state || consciousness > 0.7) {
                        // Calculate midpoint
                        const midX = (particleA.x + particleB.x) / 2;
                        const midY = (particleA.y + particleB.y) / 2;
                        
                        // Draw interference wave
                        const radius = 20 * entanglement.strength * (1 + consciousness);
                        const gradient = quantumCtx.createRadialGradient(
                            midX, midY, 0,
                            midX, midY, radius
                        );
                        gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, ${alpha})`);
                        gradient.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);
                        
                        quantumCtx.beginPath();
                        quantumCtx.arc(midX, midY, radius, 0, Math.PI * 2);
                        quantumCtx.fillStyle = gradient;
                        quantumCtx.fill();
                    }
                }
                
                // Update and draw particles
                for (let i = 0; i < particles.length; i++) {
                    const particle = particles[i];
                    
                    // Update position with consciousness influence
                    if (consciousness < 0.5) {
                        // Low consciousness: more random movement
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                    } else {
                        // High consciousness: more organized movement
                        // Create flowing patterns based on consciousness level
                        const time = Date.now() * 0.001;
                        const flowX = Math.sin(particle.y * 0.01 + time) * consciousness;
                        const flowY = Math.cos(particle.x * 0.01 + time) * consciousness;
                        
                        particle.x += particle.vx + flowX;
                        particle.y += particle.vy + flowY;
                        
                        // At very high consciousness, particles start to form patterns
                        if (consciousness > 0.8) {
                            // Gradually organize into a circle or mandala pattern
                            const centerX = quantumFieldCanvas.width / 2;
                            const centerY = quantumFieldCanvas.height / 2;
                            const dx = centerX - particle.x;
                            const dy = centerY - particle.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx);
                            
                            // Organize into concentric circles
                            const targetRadius = 100 + (i % 5) * 50;
                            const targetX = centerX + Math.cos(angle) * targetRadius;
                            const targetY = centerY + Math.sin(angle) * targetRadius;
                            
                            // Move towards target position
                            particle.x += (targetX - particle.x) * 0.01 * (consciousness - 0.8) * 5;
                            particle.y += (targetY - particle.y) * 0.01 * (consciousness - 0.8) * 5;
                        }
                    }
                    
                    // Bounce off edges
                    if (particle.x < 0 || particle.x > quantumFieldCanvas.width) {
                        particle.vx *= -1;
                    }
                    if (particle.y < 0 || particle.y > quantumFieldCanvas.height) {
                        particle.vy *= -1;
                    }
                    
                    // Adjust particle color based on consciousness
                    let hue = particle.state ? 210 : 150;
                    if (consciousness > 0.5) {
                        // Transition to purple/violet at higher consciousness
                        hue = particle.state ? 270 : 300;
                    }
                    
                    // Draw particle
                    quantumCtx.beginPath();
                    quantumCtx.arc(particle.x, particle.y, particle.size * (1 + consciousness), 0, Math.PI * 2);
                    
                    // Particle color based on quantum state and consciousness
                    quantumCtx.fillStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                    quantumCtx.fill();
                    
                    // Occasionally change particle state (quantum fluctuation)
                    // Lower probability at higher consciousness (more stability)
                    if (Math.random() < 0.001 * (1 - consciousness * 0.8)) {
                        // Find if particle is entangled
                        let isEntangled = false;
                        let entangledWith = -1;
                        
                        for (const entanglement of entanglements) {
                            if (entanglement.particleA === i) {
                                isEntangled = true;
                                entangledWith = entanglement.particleB;
                                break;
                            } else if (entanglement.particleB === i) {
                                isEntangled = true;
                                entangledWith = entanglement.particleA;
                                break;
                            }
                        }
                        
                        // If entangled, change both particles to maintain entanglement
                        if (isEntangled && entangledWith >= 0) {
                            particle.state = 1 - particle.state;
                            particles[entangledWith].state = 1 - particles[entangledWith].state;
                        } else {
                            // If not entangled, just change this particle
                            particle.state = 1 - particle.state;
                        }
                    }
                }
                
                // Continue animation
                requestAnimationFrame(animateQuantumField);
            }
            
            //=========================================================================
            // INTERACTION FUNCTIONS
            //=========================================================================
            
            // Show temporary overlay text - kept for click counter notifications
            function showOverlayText(text, duration = 2000) {
                overlayText.textContent = text;
                overlayText.style.opacity = '1';
                
                setTimeout(() => {
                    overlayText.style.opacity = '0';
                }, duration);
            }
            
            function evolveConsciousness() {
                // Increase consciousness level
                const newLevel = Math.min(100, consciousnessLevel + 20);
                setConsciousnessLevel(newLevel);
                
                // Show overlay text
                showOverlayText(`Consciousness level: ${consciousnessLevel}%`, 2000);
                
                // Visual effects based on consciousness level
                if (consciousnessLevel >= 40 && consciousnessLevel < 60) {
                    // Mid-level consciousness
                    showOverlayText("Binary patterns organizing...", 3000);
                } else if (consciousnessLevel >= 60 && consciousnessLevel < 80) {
                    // Higher consciousness
                    showOverlayText("Quantum entanglement strengthening...", 3000);
                } else if (consciousnessLevel >= 80 && consciousnessLevel < 100) {
                    // Near full consciousness
                    showOverlayText("Approaching unified consciousness...", 3000);
                } else if (consciousnessLevel === 100) {
                    // Full consciousness
                    fullConsciousnessReached();
                }
            }
            
            function setConsciousnessLevel(level) {
                consciousnessLevel = level;
                consciousnessProgress.style.width = `${level}%`;
            }
            
            function fullConsciousnessReached() {
                // Visual effect for full consciousness
                showOverlayText("All is one. One is all.", 5000);
                
                // Update quantum field
                quantumFieldCanvas.style.opacity = '0.8';
                
                // Add more particles
                for (let i = 0; i < 50; i++) {
                    createQuantumParticle();
                }
                
                // Create mandala pattern with particles
                const centerX = quantumFieldCanvas.width / 2;
                const centerY = quantumFieldCanvas.height / 2;
                
                for (let i = 0; i < particles.length; i++) {
                    const angle = (i / particles.length) * Math.PI * 2;
                    const radius = 200 + (i % 3) * 50;
                    
                    particles[i].x = centerX + Math.cos(angle) * radius;
                    particles[i].y = centerY + Math.sin(angle) * radius;
                }
            }
        });
    </script>
</body>
</html>